// This file is generated by rust-protobuf 2.3.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct StreamingMessage {
    // message fields
    pub request_id: ::std::string::String,
    // message oneof groups
    pub content: ::std::option::Option<StreamingMessage_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum StreamingMessage_oneof_content {
    start_stream(StartStream),
    worker_init_request(WorkerInitRequest),
    worker_init_response(WorkerInitResponse),
    worker_heartbeat(WorkerHeartbeat),
    worker_terminate(WorkerTerminate),
    worker_status_request(WorkerStatusRequest),
    worker_status_response(WorkerStatusResponse),
    file_change_event_request(FileChangeEventRequest),
    worker_action_response(WorkerActionResponse),
    function_load_request(FunctionLoadRequest),
    function_load_response(FunctionLoadResponse),
    invocation_request(InvocationRequest),
    invocation_response(InvocationResponse),
    invocation_cancel(InvocationCancel),
    rpc_log(RpcLog),
    function_environment_reload_request(FunctionEnvironmentReloadRequest),
    function_environment_reload_response(FunctionEnvironmentReloadResponse),
}

impl StreamingMessage {
    pub fn new() -> StreamingMessage {
        ::std::default::Default::default()
    }

    // string request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: ::std::string::String) {
        self.request_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_id(&mut self) -> &mut ::std::string::String {
        &mut self.request_id
    }

    // Take field
    pub fn take_request_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.request_id, ::std::string::String::new())
    }

    pub fn get_request_id(&self) -> &str {
        &self.request_id
    }

    // .AzureFunctionsRpcMessages.StartStream start_stream = 20;

    pub fn clear_start_stream(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_start_stream(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_stream(&mut self, v: StartStream) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_stream(&mut self) -> &mut StartStream {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(StartStream::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_stream(&mut self) -> StartStream {
        if self.has_start_stream() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(v)) => v,
                _ => panic!(),
            }
        } else {
            StartStream::new()
        }
    }

    pub fn get_start_stream(&self) -> &StartStream {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(ref v)) => v,
            _ => StartStream::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.WorkerInitRequest worker_init_request = 17;

    pub fn clear_worker_init_request(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worker_init_request(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worker_init_request(&mut self, v: WorkerInitRequest) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worker_init_request(&mut self) -> &mut WorkerInitRequest {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(WorkerInitRequest::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worker_init_request(&mut self) -> WorkerInitRequest {
        if self.has_worker_init_request() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerInitRequest::new()
        }
    }

    pub fn get_worker_init_request(&self) -> &WorkerInitRequest {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(ref v)) => v,
            _ => WorkerInitRequest::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.WorkerInitResponse worker_init_response = 16;

    pub fn clear_worker_init_response(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worker_init_response(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worker_init_response(&mut self, v: WorkerInitResponse) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worker_init_response(&mut self) -> &mut WorkerInitResponse {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(WorkerInitResponse::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worker_init_response(&mut self) -> WorkerInitResponse {
        if self.has_worker_init_response() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerInitResponse::new()
        }
    }

    pub fn get_worker_init_response(&self) -> &WorkerInitResponse {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(ref v)) => v,
            _ => WorkerInitResponse::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.WorkerHeartbeat worker_heartbeat = 15;

    pub fn clear_worker_heartbeat(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worker_heartbeat(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worker_heartbeat(&mut self, v: WorkerHeartbeat) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worker_heartbeat(&mut self) -> &mut WorkerHeartbeat {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(WorkerHeartbeat::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worker_heartbeat(&mut self) -> WorkerHeartbeat {
        if self.has_worker_heartbeat() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerHeartbeat::new()
        }
    }

    pub fn get_worker_heartbeat(&self) -> &WorkerHeartbeat {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(ref v)) => v,
            _ => WorkerHeartbeat::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.WorkerTerminate worker_terminate = 14;

    pub fn clear_worker_terminate(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worker_terminate(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worker_terminate(&mut self, v: WorkerTerminate) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worker_terminate(&mut self) -> &mut WorkerTerminate {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(WorkerTerminate::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worker_terminate(&mut self) -> WorkerTerminate {
        if self.has_worker_terminate() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerTerminate::new()
        }
    }

    pub fn get_worker_terminate(&self) -> &WorkerTerminate {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(ref v)) => v,
            _ => WorkerTerminate::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.WorkerStatusRequest worker_status_request = 12;

    pub fn clear_worker_status_request(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worker_status_request(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worker_status_request(&mut self, v: WorkerStatusRequest) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worker_status_request(&mut self) -> &mut WorkerStatusRequest {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(WorkerStatusRequest::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worker_status_request(&mut self) -> WorkerStatusRequest {
        if self.has_worker_status_request() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerStatusRequest::new()
        }
    }

    pub fn get_worker_status_request(&self) -> &WorkerStatusRequest {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(ref v)) => v,
            _ => WorkerStatusRequest::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.WorkerStatusResponse worker_status_response = 13;

    pub fn clear_worker_status_response(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worker_status_response(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worker_status_response(&mut self, v: WorkerStatusResponse) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worker_status_response(&mut self) -> &mut WorkerStatusResponse {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(WorkerStatusResponse::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worker_status_response(&mut self) -> WorkerStatusResponse {
        if self.has_worker_status_response() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerStatusResponse::new()
        }
    }

    pub fn get_worker_status_response(&self) -> &WorkerStatusResponse {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(ref v)) => v,
            _ => WorkerStatusResponse::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.FileChangeEventRequest file_change_event_request = 6;

    pub fn clear_file_change_event_request(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_file_change_event_request(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_change_event_request(&mut self, v: FileChangeEventRequest) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_change_event_request(&mut self) -> &mut FileChangeEventRequest {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(FileChangeEventRequest::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_change_event_request(&mut self) -> FileChangeEventRequest {
        if self.has_file_change_event_request() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(v)) => v,
                _ => panic!(),
            }
        } else {
            FileChangeEventRequest::new()
        }
    }

    pub fn get_file_change_event_request(&self) -> &FileChangeEventRequest {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(ref v)) => v,
            _ => FileChangeEventRequest::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.WorkerActionResponse worker_action_response = 7;

    pub fn clear_worker_action_response(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_worker_action_response(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_worker_action_response(&mut self, v: WorkerActionResponse) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_worker_action_response(&mut self) -> &mut WorkerActionResponse {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(WorkerActionResponse::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_worker_action_response(&mut self) -> WorkerActionResponse {
        if self.has_worker_action_response() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerActionResponse::new()
        }
    }

    pub fn get_worker_action_response(&self) -> &WorkerActionResponse {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(ref v)) => v,
            _ => WorkerActionResponse::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.FunctionLoadRequest function_load_request = 8;

    pub fn clear_function_load_request(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_function_load_request(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function_load_request(&mut self, v: FunctionLoadRequest) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function_load_request(&mut self) -> &mut FunctionLoadRequest {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(FunctionLoadRequest::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function_load_request(&mut self) -> FunctionLoadRequest {
        if self.has_function_load_request() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(v)) => v,
                _ => panic!(),
            }
        } else {
            FunctionLoadRequest::new()
        }
    }

    pub fn get_function_load_request(&self) -> &FunctionLoadRequest {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(ref v)) => v,
            _ => FunctionLoadRequest::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.FunctionLoadResponse function_load_response = 9;

    pub fn clear_function_load_response(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_function_load_response(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function_load_response(&mut self, v: FunctionLoadResponse) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function_load_response(&mut self) -> &mut FunctionLoadResponse {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(FunctionLoadResponse::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function_load_response(&mut self) -> FunctionLoadResponse {
        if self.has_function_load_response() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(v)) => v,
                _ => panic!(),
            }
        } else {
            FunctionLoadResponse::new()
        }
    }

    pub fn get_function_load_response(&self) -> &FunctionLoadResponse {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(ref v)) => v,
            _ => FunctionLoadResponse::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.InvocationRequest invocation_request = 4;

    pub fn clear_invocation_request(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_invocation_request(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_invocation_request(&mut self, v: InvocationRequest) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_invocation_request(&mut self) -> &mut InvocationRequest {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(InvocationRequest::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_invocation_request(&mut self) -> InvocationRequest {
        if self.has_invocation_request() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(v)) => v,
                _ => panic!(),
            }
        } else {
            InvocationRequest::new()
        }
    }

    pub fn get_invocation_request(&self) -> &InvocationRequest {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(ref v)) => v,
            _ => InvocationRequest::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.InvocationResponse invocation_response = 5;

    pub fn clear_invocation_response(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_invocation_response(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_invocation_response(&mut self, v: InvocationResponse) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_invocation_response(&mut self) -> &mut InvocationResponse {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(InvocationResponse::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_invocation_response(&mut self) -> InvocationResponse {
        if self.has_invocation_response() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(v)) => v,
                _ => panic!(),
            }
        } else {
            InvocationResponse::new()
        }
    }

    pub fn get_invocation_response(&self) -> &InvocationResponse {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(ref v)) => v,
            _ => InvocationResponse::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.InvocationCancel invocation_cancel = 21;

    pub fn clear_invocation_cancel(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_invocation_cancel(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_invocation_cancel(&mut self, v: InvocationCancel) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_invocation_cancel(&mut self) -> &mut InvocationCancel {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(InvocationCancel::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_invocation_cancel(&mut self) -> InvocationCancel {
        if self.has_invocation_cancel() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(v)) => v,
                _ => panic!(),
            }
        } else {
            InvocationCancel::new()
        }
    }

    pub fn get_invocation_cancel(&self) -> &InvocationCancel {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(ref v)) => v,
            _ => InvocationCancel::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.RpcLog rpc_log = 2;

    pub fn clear_rpc_log(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_rpc_log(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rpc_log(&mut self, v: RpcLog) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rpc_log(&mut self) -> &mut RpcLog {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(RpcLog::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rpc_log(&mut self) -> RpcLog {
        if self.has_rpc_log() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(v)) => v,
                _ => panic!(),
            }
        } else {
            RpcLog::new()
        }
    }

    pub fn get_rpc_log(&self) -> &RpcLog {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(ref v)) => v,
            _ => RpcLog::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.FunctionEnvironmentReloadRequest function_environment_reload_request = 25;

    pub fn clear_function_environment_reload_request(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_function_environment_reload_request(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function_environment_reload_request(&mut self, v: FunctionEnvironmentReloadRequest) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function_environment_reload_request(&mut self) -> &mut FunctionEnvironmentReloadRequest {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(FunctionEnvironmentReloadRequest::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function_environment_reload_request(&mut self) -> FunctionEnvironmentReloadRequest {
        if self.has_function_environment_reload_request() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(v)) => v,
                _ => panic!(),
            }
        } else {
            FunctionEnvironmentReloadRequest::new()
        }
    }

    pub fn get_function_environment_reload_request(&self) -> &FunctionEnvironmentReloadRequest {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(ref v)) => v,
            _ => FunctionEnvironmentReloadRequest::default_instance(),
        }
    }

    // .AzureFunctionsRpcMessages.FunctionEnvironmentReloadResponse function_environment_reload_response = 26;

    pub fn clear_function_environment_reload_response(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_function_environment_reload_response(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function_environment_reload_response(&mut self, v: FunctionEnvironmentReloadResponse) {
        self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function_environment_reload_response(&mut self) -> &mut FunctionEnvironmentReloadResponse {
        if let ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(FunctionEnvironmentReloadResponse::new()));
        }
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function_environment_reload_response(&mut self) -> FunctionEnvironmentReloadResponse {
        if self.has_function_environment_reload_response() {
            match self.content.take() {
                ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(v)) => v,
                _ => panic!(),
            }
        } else {
            FunctionEnvironmentReloadResponse::new()
        }
    }

    pub fn get_function_environment_reload_response(&self) -> &FunctionEnvironmentReloadResponse {
        match self.content {
            ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(ref v)) => v,
            _ => FunctionEnvironmentReloadResponse::default_instance(),
        }
    }
}

impl ::protobuf::Message for StreamingMessage {
    fn is_initialized(&self) -> bool {
        if let Some(StreamingMessage_oneof_content::start_stream(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::worker_init_request(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::worker_init_response(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::worker_heartbeat(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::worker_terminate(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::worker_status_request(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::worker_status_response(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::file_change_event_request(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::worker_action_response(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::function_load_request(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::function_load_response(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::invocation_request(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::invocation_response(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::invocation_cancel(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::rpc_log(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::function_environment_reload_request(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingMessage_oneof_content::function_environment_reload_response(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.request_id)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::start_stream(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_request(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_init_response(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_heartbeat(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_terminate(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_request(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_status_response(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::file_change_event_request(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::worker_action_response(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_request(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_load_response(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_request(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_response(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::invocation_cancel(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::rpc_log(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_request(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(StreamingMessage_oneof_content::function_environment_reload_response(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.request_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.request_id);
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &StreamingMessage_oneof_content::start_stream(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::worker_init_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::worker_init_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::worker_heartbeat(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::worker_terminate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::worker_status_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::worker_status_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::file_change_event_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::worker_action_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::function_load_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::function_load_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::invocation_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::invocation_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::invocation_cancel(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::rpc_log(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::function_environment_reload_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingMessage_oneof_content::function_environment_reload_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.request_id.is_empty() {
            os.write_string(1, &self.request_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &StreamingMessage_oneof_content::start_stream(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::worker_init_request(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::worker_init_response(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::worker_heartbeat(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::worker_terminate(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::worker_status_request(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::worker_status_response(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::file_change_event_request(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::worker_action_response(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::function_load_request(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::function_load_response(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::invocation_request(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::invocation_response(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::invocation_cancel(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::rpc_log(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::function_environment_reload_request(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingMessage_oneof_content::function_environment_reload_response(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingMessage {
        StreamingMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "request_id",
                    |m: &StreamingMessage| { &m.request_id },
                    |m: &mut StreamingMessage| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StartStream>(
                    "start_stream",
                    StreamingMessage::has_start_stream,
                    StreamingMessage::get_start_stream,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerInitRequest>(
                    "worker_init_request",
                    StreamingMessage::has_worker_init_request,
                    StreamingMessage::get_worker_init_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerInitResponse>(
                    "worker_init_response",
                    StreamingMessage::has_worker_init_response,
                    StreamingMessage::get_worker_init_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerHeartbeat>(
                    "worker_heartbeat",
                    StreamingMessage::has_worker_heartbeat,
                    StreamingMessage::get_worker_heartbeat,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerTerminate>(
                    "worker_terminate",
                    StreamingMessage::has_worker_terminate,
                    StreamingMessage::get_worker_terminate,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerStatusRequest>(
                    "worker_status_request",
                    StreamingMessage::has_worker_status_request,
                    StreamingMessage::get_worker_status_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerStatusResponse>(
                    "worker_status_response",
                    StreamingMessage::has_worker_status_response,
                    StreamingMessage::get_worker_status_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FileChangeEventRequest>(
                    "file_change_event_request",
                    StreamingMessage::has_file_change_event_request,
                    StreamingMessage::get_file_change_event_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerActionResponse>(
                    "worker_action_response",
                    StreamingMessage::has_worker_action_response,
                    StreamingMessage::get_worker_action_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FunctionLoadRequest>(
                    "function_load_request",
                    StreamingMessage::has_function_load_request,
                    StreamingMessage::get_function_load_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FunctionLoadResponse>(
                    "function_load_response",
                    StreamingMessage::has_function_load_response,
                    StreamingMessage::get_function_load_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InvocationRequest>(
                    "invocation_request",
                    StreamingMessage::has_invocation_request,
                    StreamingMessage::get_invocation_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InvocationResponse>(
                    "invocation_response",
                    StreamingMessage::has_invocation_response,
                    StreamingMessage::get_invocation_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InvocationCancel>(
                    "invocation_cancel",
                    StreamingMessage::has_invocation_cancel,
                    StreamingMessage::get_invocation_cancel,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RpcLog>(
                    "rpc_log",
                    StreamingMessage::has_rpc_log,
                    StreamingMessage::get_rpc_log,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FunctionEnvironmentReloadRequest>(
                    "function_environment_reload_request",
                    StreamingMessage::has_function_environment_reload_request,
                    StreamingMessage::get_function_environment_reload_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FunctionEnvironmentReloadResponse>(
                    "function_environment_reload_response",
                    StreamingMessage::has_function_environment_reload_response,
                    StreamingMessage::get_function_environment_reload_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamingMessage>(
                    "StreamingMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamingMessage {
        static mut instance: ::protobuf::lazy::Lazy<StreamingMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamingMessage,
        };
        unsafe {
            instance.get(StreamingMessage::new)
        }
    }
}

impl ::protobuf::Clear for StreamingMessage {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_start_stream();
        self.clear_worker_init_request();
        self.clear_worker_init_response();
        self.clear_worker_heartbeat();
        self.clear_worker_terminate();
        self.clear_worker_status_request();
        self.clear_worker_status_response();
        self.clear_file_change_event_request();
        self.clear_worker_action_response();
        self.clear_function_load_request();
        self.clear_function_load_response();
        self.clear_invocation_request();
        self.clear_invocation_response();
        self.clear_invocation_cancel();
        self.clear_rpc_log();
        self.clear_function_environment_reload_request();
        self.clear_function_environment_reload_response();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartStream {
    // message fields
    pub worker_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StartStream {
    pub fn new() -> StartStream {
        ::std::default::Default::default()
    }

    // string worker_id = 2;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }
}

impl ::protobuf::Message for StartStream {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.worker_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_id.is_empty() {
            os.write_string(2, &self.worker_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartStream {
        StartStream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &StartStream| { &m.worker_id },
                    |m: &mut StartStream| { &mut m.worker_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartStream>(
                    "StartStream",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartStream {
        static mut instance: ::protobuf::lazy::Lazy<StartStream> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartStream,
        };
        unsafe {
            instance.get(StartStream::new)
        }
    }
}

impl ::protobuf::Clear for StartStream {
    fn clear(&mut self) {
        self.clear_worker_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartStream {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerInitRequest {
    // message fields
    pub host_version: ::std::string::String,
    pub capabilities: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub log_categories: ::std::collections::HashMap<::std::string::String, RpcLog_Level>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WorkerInitRequest {
    pub fn new() -> WorkerInitRequest {
        ::std::default::Default::default()
    }

    // string host_version = 1;

    pub fn clear_host_version(&mut self) {
        self.host_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_version(&mut self, v: ::std::string::String) {
        self.host_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_version(&mut self) -> &mut ::std::string::String {
        &mut self.host_version
    }

    // Take field
    pub fn take_host_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_version, ::std::string::String::new())
    }

    pub fn get_host_version(&self) -> &str {
        &self.host_version
    }

    // repeated .AzureFunctionsRpcMessages.WorkerInitRequest.CapabilitiesEntry capabilities = 2;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.capabilities, ::std::collections::HashMap::new())
    }

    pub fn get_capabilities(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.capabilities
    }

    // repeated .AzureFunctionsRpcMessages.WorkerInitRequest.LogCategoriesEntry log_categories = 3;

    pub fn clear_log_categories(&mut self) {
        self.log_categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_categories(&mut self, v: ::std::collections::HashMap<::std::string::String, RpcLog_Level>) {
        self.log_categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_log_categories(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, RpcLog_Level> {
        &mut self.log_categories
    }

    // Take field
    pub fn take_log_categories(&mut self) -> ::std::collections::HashMap<::std::string::String, RpcLog_Level> {
        ::std::mem::replace(&mut self.log_categories, ::std::collections::HashMap::new())
    }

    pub fn get_log_categories(&self) -> &::std::collections::HashMap<::std::string::String, RpcLog_Level> {
        &self.log_categories
    }
}

impl ::protobuf::Message for WorkerInitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_version)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.capabilities)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeEnum<RpcLog_Level>>(wire_type, is, &mut self.log_categories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host_version);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.capabilities);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeEnum<RpcLog_Level>>(3, &self.log_categories);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.host_version.is_empty() {
            os.write_string(1, &self.host_version)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.capabilities, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeEnum<RpcLog_Level>>(3, &self.log_categories, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerInitRequest {
        WorkerInitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host_version",
                    |m: &WorkerInitRequest| { &m.host_version },
                    |m: &mut WorkerInitRequest| { &mut m.host_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "capabilities",
                    |m: &WorkerInitRequest| { &m.capabilities },
                    |m: &mut WorkerInitRequest| { &mut m.capabilities },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeEnum<RpcLog_Level>>(
                    "log_categories",
                    |m: &WorkerInitRequest| { &m.log_categories },
                    |m: &mut WorkerInitRequest| { &mut m.log_categories },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerInitRequest>(
                    "WorkerInitRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerInitRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerInitRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerInitRequest,
        };
        unsafe {
            instance.get(WorkerInitRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerInitRequest {
    fn clear(&mut self) {
        self.clear_host_version();
        self.clear_capabilities();
        self.clear_log_categories();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerInitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerInitResponse {
    // message fields
    pub worker_version: ::std::string::String,
    pub capabilities: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub result: ::protobuf::SingularPtrField<StatusResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WorkerInitResponse {
    pub fn new() -> WorkerInitResponse {
        ::std::default::Default::default()
    }

    // string worker_version = 1;

    pub fn clear_worker_version(&mut self) {
        self.worker_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_version(&mut self, v: ::std::string::String) {
        self.worker_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_version(&mut self) -> &mut ::std::string::String {
        &mut self.worker_version
    }

    // Take field
    pub fn take_worker_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_version, ::std::string::String::new())
    }

    pub fn get_worker_version(&self) -> &str {
        &self.worker_version
    }

    // repeated .AzureFunctionsRpcMessages.WorkerInitResponse.CapabilitiesEntry capabilities = 2;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.capabilities, ::std::collections::HashMap::new())
    }

    pub fn get_capabilities(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.capabilities
    }

    // .AzureFunctionsRpcMessages.StatusResult result = 3;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: StatusResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut StatusResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> StatusResult {
        self.result.take().unwrap_or_else(|| StatusResult::new())
    }

    pub fn get_result(&self) -> &StatusResult {
        self.result.as_ref().unwrap_or_else(|| StatusResult::default_instance())
    }
}

impl ::protobuf::Message for WorkerInitResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_version)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.capabilities)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_version);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.capabilities);
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_version.is_empty() {
            os.write_string(1, &self.worker_version)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.capabilities, os)?;
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerInitResponse {
        WorkerInitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_version",
                    |m: &WorkerInitResponse| { &m.worker_version },
                    |m: &mut WorkerInitResponse| { &mut m.worker_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "capabilities",
                    |m: &WorkerInitResponse| { &m.capabilities },
                    |m: &mut WorkerInitResponse| { &mut m.capabilities },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusResult>>(
                    "result",
                    |m: &WorkerInitResponse| { &m.result },
                    |m: &mut WorkerInitResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerInitResponse>(
                    "WorkerInitResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerInitResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerInitResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerInitResponse,
        };
        unsafe {
            instance.get(WorkerInitResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerInitResponse {
    fn clear(&mut self) {
        self.clear_worker_version();
        self.clear_capabilities();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerInitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusResult {
    // message fields
    pub status: StatusResult_Status,
    pub result: ::std::string::String,
    pub exception: ::protobuf::SingularPtrField<RpcException>,
    pub logs: ::protobuf::RepeatedField<RpcLog>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StatusResult {
    pub fn new() -> StatusResult {
        ::std::default::Default::default()
    }

    // .AzureFunctionsRpcMessages.StatusResult.Status status = 4;

    pub fn clear_status(&mut self) {
        self.status = StatusResult_Status::Failure;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StatusResult_Status) {
        self.status = v;
    }

    pub fn get_status(&self) -> StatusResult_Status {
        self.status
    }

    // string result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::std::string::String) {
        self.result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ::std::string::String {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.result, ::std::string::String::new())
    }

    pub fn get_result(&self) -> &str {
        &self.result
    }

    // .AzureFunctionsRpcMessages.RpcException exception = 2;

    pub fn clear_exception(&mut self) {
        self.exception.clear();
    }

    pub fn has_exception(&self) -> bool {
        self.exception.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: RpcException) {
        self.exception = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception(&mut self) -> &mut RpcException {
        if self.exception.is_none() {
            self.exception.set_default();
        }
        self.exception.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception(&mut self) -> RpcException {
        self.exception.take().unwrap_or_else(|| RpcException::new())
    }

    pub fn get_exception(&self) -> &RpcException {
        self.exception.as_ref().unwrap_or_else(|| RpcException::default_instance())
    }

    // repeated .AzureFunctionsRpcMessages.RpcLog logs = 3;

    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<RpcLog>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<RpcLog> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<RpcLog> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }

    pub fn get_logs(&self) -> &[RpcLog] {
        &self.logs
    }
}

impl ::protobuf::Message for StatusResult {
    fn is_initialized(&self) -> bool {
        for v in &self.exception {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exception)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != StatusResult_Status::Failure {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.result);
        }
        if let Some(ref v) = self.exception.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != StatusResult_Status::Failure {
            os.write_enum(4, self.status.value())?;
        }
        if !self.result.is_empty() {
            os.write_string(1, &self.result)?;
        }
        if let Some(ref v) = self.exception.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.logs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusResult {
        StatusResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusResult_Status>>(
                    "status",
                    |m: &StatusResult| { &m.status },
                    |m: &mut StatusResult| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "result",
                    |m: &StatusResult| { &m.result },
                    |m: &mut StatusResult| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RpcException>>(
                    "exception",
                    |m: &StatusResult| { &m.exception },
                    |m: &mut StatusResult| { &mut m.exception },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RpcLog>>(
                    "logs",
                    |m: &StatusResult| { &m.logs },
                    |m: &mut StatusResult| { &mut m.logs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusResult>(
                    "StatusResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusResult {
        static mut instance: ::protobuf::lazy::Lazy<StatusResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusResult,
        };
        unsafe {
            instance.get(StatusResult::new)
        }
    }
}

impl ::protobuf::Clear for StatusResult {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_result();
        self.clear_exception();
        self.clear_logs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatusResult_Status {
    Failure = 0,
    Success = 1,
    Cancelled = 2,
}

impl ::protobuf::ProtobufEnum for StatusResult_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatusResult_Status> {
        match value {
            0 => ::std::option::Option::Some(StatusResult_Status::Failure),
            1 => ::std::option::Option::Some(StatusResult_Status::Success),
            2 => ::std::option::Option::Some(StatusResult_Status::Cancelled),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatusResult_Status] = &[
            StatusResult_Status::Failure,
            StatusResult_Status::Success,
            StatusResult_Status::Cancelled,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StatusResult_Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StatusResult_Status {
}

impl ::std::default::Default for StatusResult_Status {
    fn default() -> Self {
        StatusResult_Status::Failure
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusResult_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerHeartbeat {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WorkerHeartbeat {
    pub fn new() -> WorkerHeartbeat {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WorkerHeartbeat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerHeartbeat {
        WorkerHeartbeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WorkerHeartbeat>(
                    "WorkerHeartbeat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerHeartbeat {
        static mut instance: ::protobuf::lazy::Lazy<WorkerHeartbeat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerHeartbeat,
        };
        unsafe {
            instance.get(WorkerHeartbeat::new)
        }
    }
}

impl ::protobuf::Clear for WorkerHeartbeat {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerHeartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerHeartbeat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerTerminate {
    // message fields
    pub grace_period: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WorkerTerminate {
    pub fn new() -> WorkerTerminate {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration grace_period = 1;

    pub fn clear_grace_period(&mut self) {
        self.grace_period.clear();
    }

    pub fn has_grace_period(&self) -> bool {
        self.grace_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grace_period(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.grace_period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grace_period(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.grace_period.is_none() {
            self.grace_period.set_default();
        }
        self.grace_period.as_mut().unwrap()
    }

    // Take field
    pub fn take_grace_period(&mut self) -> ::protobuf::well_known_types::Duration {
        self.grace_period.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    pub fn get_grace_period(&self) -> &::protobuf::well_known_types::Duration {
        self.grace_period.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
}

impl ::protobuf::Message for WorkerTerminate {
    fn is_initialized(&self) -> bool {
        for v in &self.grace_period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grace_period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.grace_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.grace_period.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerTerminate {
        WorkerTerminate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "grace_period",
                    |m: &WorkerTerminate| { &m.grace_period },
                    |m: &mut WorkerTerminate| { &mut m.grace_period },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerTerminate>(
                    "WorkerTerminate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerTerminate {
        static mut instance: ::protobuf::lazy::Lazy<WorkerTerminate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerTerminate,
        };
        unsafe {
            instance.get(WorkerTerminate::new)
        }
    }
}

impl ::protobuf::Clear for WorkerTerminate {
    fn clear(&mut self) {
        self.clear_grace_period();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerTerminate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerTerminate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileChangeEventRequest {
    // message fields
    pub field_type: FileChangeEventRequest_Type,
    pub full_path: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FileChangeEventRequest {
    pub fn new() -> FileChangeEventRequest {
        ::std::default::Default::default()
    }

    // .AzureFunctionsRpcMessages.FileChangeEventRequest.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = FileChangeEventRequest_Type::Unknown;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: FileChangeEventRequest_Type) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> FileChangeEventRequest_Type {
        self.field_type
    }

    // string full_path = 2;

    pub fn clear_full_path(&mut self) {
        self.full_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_full_path(&mut self, v: ::std::string::String) {
        self.full_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_path(&mut self) -> &mut ::std::string::String {
        &mut self.full_path
    }

    // Take field
    pub fn take_full_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.full_path, ::std::string::String::new())
    }

    pub fn get_full_path(&self) -> &str {
        &self.full_path
    }

    // string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for FileChangeEventRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.full_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != FileChangeEventRequest_Type::Unknown {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.full_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.full_path);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != FileChangeEventRequest_Type::Unknown {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.full_path.is_empty() {
            os.write_string(2, &self.full_path)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileChangeEventRequest {
        FileChangeEventRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FileChangeEventRequest_Type>>(
                    "type",
                    |m: &FileChangeEventRequest| { &m.field_type },
                    |m: &mut FileChangeEventRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "full_path",
                    |m: &FileChangeEventRequest| { &m.full_path },
                    |m: &mut FileChangeEventRequest| { &mut m.full_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &FileChangeEventRequest| { &m.name },
                    |m: &mut FileChangeEventRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FileChangeEventRequest>(
                    "FileChangeEventRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileChangeEventRequest {
        static mut instance: ::protobuf::lazy::Lazy<FileChangeEventRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileChangeEventRequest,
        };
        unsafe {
            instance.get(FileChangeEventRequest::new)
        }
    }
}

impl ::protobuf::Clear for FileChangeEventRequest {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_full_path();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileChangeEventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileChangeEventRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FileChangeEventRequest_Type {
    Unknown = 0,
    Created = 1,
    Deleted = 2,
    Changed = 4,
    Renamed = 8,
    All = 15,
}

impl ::protobuf::ProtobufEnum for FileChangeEventRequest_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileChangeEventRequest_Type> {
        match value {
            0 => ::std::option::Option::Some(FileChangeEventRequest_Type::Unknown),
            1 => ::std::option::Option::Some(FileChangeEventRequest_Type::Created),
            2 => ::std::option::Option::Some(FileChangeEventRequest_Type::Deleted),
            4 => ::std::option::Option::Some(FileChangeEventRequest_Type::Changed),
            8 => ::std::option::Option::Some(FileChangeEventRequest_Type::Renamed),
            15 => ::std::option::Option::Some(FileChangeEventRequest_Type::All),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FileChangeEventRequest_Type] = &[
            FileChangeEventRequest_Type::Unknown,
            FileChangeEventRequest_Type::Created,
            FileChangeEventRequest_Type::Deleted,
            FileChangeEventRequest_Type::Changed,
            FileChangeEventRequest_Type::Renamed,
            FileChangeEventRequest_Type::All,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FileChangeEventRequest_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FileChangeEventRequest_Type {
}

impl ::std::default::Default for FileChangeEventRequest_Type {
    fn default() -> Self {
        FileChangeEventRequest_Type::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for FileChangeEventRequest_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerActionResponse {
    // message fields
    pub action: WorkerActionResponse_Action,
    pub reason: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WorkerActionResponse {
    pub fn new() -> WorkerActionResponse {
        ::std::default::Default::default()
    }

    // .AzureFunctionsRpcMessages.WorkerActionResponse.Action action = 1;

    pub fn clear_action(&mut self) {
        self.action = WorkerActionResponse_Action::Restart;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: WorkerActionResponse_Action) {
        self.action = v;
    }

    pub fn get_action(&self) -> WorkerActionResponse_Action {
        self.action
    }

    // string reason = 2;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        &self.reason
    }
}

impl ::protobuf::Message for WorkerActionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != WorkerActionResponse_Action::Restart {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.action != WorkerActionResponse_Action::Restart {
            os.write_enum(1, self.action.value())?;
        }
        if !self.reason.is_empty() {
            os.write_string(2, &self.reason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerActionResponse {
        WorkerActionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorkerActionResponse_Action>>(
                    "action",
                    |m: &WorkerActionResponse| { &m.action },
                    |m: &mut WorkerActionResponse| { &mut m.action },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    |m: &WorkerActionResponse| { &m.reason },
                    |m: &mut WorkerActionResponse| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerActionResponse>(
                    "WorkerActionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerActionResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerActionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerActionResponse,
        };
        unsafe {
            instance.get(WorkerActionResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerActionResponse {
    fn clear(&mut self) {
        self.clear_action();
        self.clear_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerActionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerActionResponse_Action {
    Restart = 0,
    Reload = 1,
}

impl ::protobuf::ProtobufEnum for WorkerActionResponse_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerActionResponse_Action> {
        match value {
            0 => ::std::option::Option::Some(WorkerActionResponse_Action::Restart),
            1 => ::std::option::Option::Some(WorkerActionResponse_Action::Reload),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerActionResponse_Action] = &[
            WorkerActionResponse_Action::Restart,
            WorkerActionResponse_Action::Reload,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WorkerActionResponse_Action", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WorkerActionResponse_Action {
}

impl ::std::default::Default for WorkerActionResponse_Action {
    fn default() -> Self {
        WorkerActionResponse_Action::Restart
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerActionResponse_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WorkerStatusRequest {
    pub fn new() -> WorkerStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WorkerStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerStatusRequest {
        WorkerStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WorkerStatusRequest>(
                    "WorkerStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerStatusRequest,
        };
        unsafe {
            instance.get(WorkerStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerStatusResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl WorkerStatusResponse {
    pub fn new() -> WorkerStatusResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WorkerStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerStatusResponse {
        WorkerStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WorkerStatusResponse>(
                    "WorkerStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerStatusResponse,
        };
        unsafe {
            instance.get(WorkerStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerStatusResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionEnvironmentReloadRequest {
    // message fields
    pub environment_variables: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FunctionEnvironmentReloadRequest {
    pub fn new() -> FunctionEnvironmentReloadRequest {
        ::std::default::Default::default()
    }

    // repeated .AzureFunctionsRpcMessages.FunctionEnvironmentReloadRequest.EnvironmentVariablesEntry environment_variables = 1;

    pub fn clear_environment_variables(&mut self) {
        self.environment_variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_environment_variables(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.environment_variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_environment_variables(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.environment_variables
    }

    // Take field
    pub fn take_environment_variables(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.environment_variables, ::std::collections::HashMap::new())
    }

    pub fn get_environment_variables(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.environment_variables
    }
}

impl ::protobuf::Message for FunctionEnvironmentReloadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.environment_variables)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.environment_variables);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.environment_variables, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionEnvironmentReloadRequest {
        FunctionEnvironmentReloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "environment_variables",
                    |m: &FunctionEnvironmentReloadRequest| { &m.environment_variables },
                    |m: &mut FunctionEnvironmentReloadRequest| { &mut m.environment_variables },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FunctionEnvironmentReloadRequest>(
                    "FunctionEnvironmentReloadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FunctionEnvironmentReloadRequest {
        static mut instance: ::protobuf::lazy::Lazy<FunctionEnvironmentReloadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FunctionEnvironmentReloadRequest,
        };
        unsafe {
            instance.get(FunctionEnvironmentReloadRequest::new)
        }
    }
}

impl ::protobuf::Clear for FunctionEnvironmentReloadRequest {
    fn clear(&mut self) {
        self.clear_environment_variables();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionEnvironmentReloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionEnvironmentReloadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionEnvironmentReloadResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<StatusResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FunctionEnvironmentReloadResponse {
    pub fn new() -> FunctionEnvironmentReloadResponse {
        ::std::default::Default::default()
    }

    // .AzureFunctionsRpcMessages.StatusResult result = 3;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: StatusResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut StatusResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> StatusResult {
        self.result.take().unwrap_or_else(|| StatusResult::new())
    }

    pub fn get_result(&self) -> &StatusResult {
        self.result.as_ref().unwrap_or_else(|| StatusResult::default_instance())
    }
}

impl ::protobuf::Message for FunctionEnvironmentReloadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionEnvironmentReloadResponse {
        FunctionEnvironmentReloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusResult>>(
                    "result",
                    |m: &FunctionEnvironmentReloadResponse| { &m.result },
                    |m: &mut FunctionEnvironmentReloadResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FunctionEnvironmentReloadResponse>(
                    "FunctionEnvironmentReloadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FunctionEnvironmentReloadResponse {
        static mut instance: ::protobuf::lazy::Lazy<FunctionEnvironmentReloadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FunctionEnvironmentReloadResponse,
        };
        unsafe {
            instance.get(FunctionEnvironmentReloadResponse::new)
        }
    }
}

impl ::protobuf::Clear for FunctionEnvironmentReloadResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionEnvironmentReloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionEnvironmentReloadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionLoadRequest {
    // message fields
    pub function_id: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<RpcFunctionMetadata>,
    pub managed_dependency_enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FunctionLoadRequest {
    pub fn new() -> FunctionLoadRequest {
        ::std::default::Default::default()
    }

    // string function_id = 1;

    pub fn clear_function_id(&mut self) {
        self.function_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: ::std::string::String) {
        self.function_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_id(&mut self) -> &mut ::std::string::String {
        &mut self.function_id
    }

    // Take field
    pub fn take_function_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_id, ::std::string::String::new())
    }

    pub fn get_function_id(&self) -> &str {
        &self.function_id
    }

    // .AzureFunctionsRpcMessages.RpcFunctionMetadata metadata = 2;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: RpcFunctionMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut RpcFunctionMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> RpcFunctionMetadata {
        self.metadata.take().unwrap_or_else(|| RpcFunctionMetadata::new())
    }

    pub fn get_metadata(&self) -> &RpcFunctionMetadata {
        self.metadata.as_ref().unwrap_or_else(|| RpcFunctionMetadata::default_instance())
    }

    // bool managed_dependency_enabled = 3;

    pub fn clear_managed_dependency_enabled(&mut self) {
        self.managed_dependency_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_managed_dependency_enabled(&mut self, v: bool) {
        self.managed_dependency_enabled = v;
    }

    pub fn get_managed_dependency_enabled(&self) -> bool {
        self.managed_dependency_enabled
    }
}

impl ::protobuf::Message for FunctionLoadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.managed_dependency_enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function_id);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.managed_dependency_enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.function_id.is_empty() {
            os.write_string(1, &self.function_id)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.managed_dependency_enabled != false {
            os.write_bool(3, self.managed_dependency_enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionLoadRequest {
        FunctionLoadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "function_id",
                    |m: &FunctionLoadRequest| { &m.function_id },
                    |m: &mut FunctionLoadRequest| { &mut m.function_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RpcFunctionMetadata>>(
                    "metadata",
                    |m: &FunctionLoadRequest| { &m.metadata },
                    |m: &mut FunctionLoadRequest| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "managed_dependency_enabled",
                    |m: &FunctionLoadRequest| { &m.managed_dependency_enabled },
                    |m: &mut FunctionLoadRequest| { &mut m.managed_dependency_enabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FunctionLoadRequest>(
                    "FunctionLoadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FunctionLoadRequest {
        static mut instance: ::protobuf::lazy::Lazy<FunctionLoadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FunctionLoadRequest,
        };
        unsafe {
            instance.get(FunctionLoadRequest::new)
        }
    }
}

impl ::protobuf::Clear for FunctionLoadRequest {
    fn clear(&mut self) {
        self.clear_function_id();
        self.clear_metadata();
        self.clear_managed_dependency_enabled();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionLoadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionLoadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionLoadResponse {
    // message fields
    pub function_id: ::std::string::String,
    pub result: ::protobuf::SingularPtrField<StatusResult>,
    pub is_dependency_downloaded: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FunctionLoadResponse {
    pub fn new() -> FunctionLoadResponse {
        ::std::default::Default::default()
    }

    // string function_id = 1;

    pub fn clear_function_id(&mut self) {
        self.function_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: ::std::string::String) {
        self.function_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_id(&mut self) -> &mut ::std::string::String {
        &mut self.function_id
    }

    // Take field
    pub fn take_function_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_id, ::std::string::String::new())
    }

    pub fn get_function_id(&self) -> &str {
        &self.function_id
    }

    // .AzureFunctionsRpcMessages.StatusResult result = 2;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: StatusResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut StatusResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> StatusResult {
        self.result.take().unwrap_or_else(|| StatusResult::new())
    }

    pub fn get_result(&self) -> &StatusResult {
        self.result.as_ref().unwrap_or_else(|| StatusResult::default_instance())
    }

    // bool is_dependency_downloaded = 3;

    pub fn clear_is_dependency_downloaded(&mut self) {
        self.is_dependency_downloaded = false;
    }

    // Param is passed by value, moved
    pub fn set_is_dependency_downloaded(&mut self, v: bool) {
        self.is_dependency_downloaded = v;
    }

    pub fn get_is_dependency_downloaded(&self) -> bool {
        self.is_dependency_downloaded
    }
}

impl ::protobuf::Message for FunctionLoadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_dependency_downloaded = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function_id);
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_dependency_downloaded != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.function_id.is_empty() {
            os.write_string(1, &self.function_id)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_dependency_downloaded != false {
            os.write_bool(3, self.is_dependency_downloaded)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionLoadResponse {
        FunctionLoadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "function_id",
                    |m: &FunctionLoadResponse| { &m.function_id },
                    |m: &mut FunctionLoadResponse| { &mut m.function_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusResult>>(
                    "result",
                    |m: &FunctionLoadResponse| { &m.result },
                    |m: &mut FunctionLoadResponse| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_dependency_downloaded",
                    |m: &FunctionLoadResponse| { &m.is_dependency_downloaded },
                    |m: &mut FunctionLoadResponse| { &mut m.is_dependency_downloaded },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FunctionLoadResponse>(
                    "FunctionLoadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FunctionLoadResponse {
        static mut instance: ::protobuf::lazy::Lazy<FunctionLoadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FunctionLoadResponse,
        };
        unsafe {
            instance.get(FunctionLoadResponse::new)
        }
    }
}

impl ::protobuf::Clear for FunctionLoadResponse {
    fn clear(&mut self) {
        self.clear_function_id();
        self.clear_result();
        self.clear_is_dependency_downloaded();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionLoadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionLoadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcFunctionMetadata {
    // message fields
    pub name: ::std::string::String,
    pub directory: ::std::string::String,
    pub script_file: ::std::string::String,
    pub entry_point: ::std::string::String,
    pub bindings: ::std::collections::HashMap<::std::string::String, BindingInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RpcFunctionMetadata {
    pub fn new() -> RpcFunctionMetadata {
        ::std::default::Default::default()
    }

    // string name = 4;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string directory = 1;

    pub fn clear_directory(&mut self) {
        self.directory.clear();
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: ::std::string::String) {
        self.directory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut ::std::string::String {
        &mut self.directory
    }

    // Take field
    pub fn take_directory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.directory, ::std::string::String::new())
    }

    pub fn get_directory(&self) -> &str {
        &self.directory
    }

    // string script_file = 2;

    pub fn clear_script_file(&mut self) {
        self.script_file.clear();
    }

    // Param is passed by value, moved
    pub fn set_script_file(&mut self, v: ::std::string::String) {
        self.script_file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script_file(&mut self) -> &mut ::std::string::String {
        &mut self.script_file
    }

    // Take field
    pub fn take_script_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.script_file, ::std::string::String::new())
    }

    pub fn get_script_file(&self) -> &str {
        &self.script_file
    }

    // string entry_point = 3;

    pub fn clear_entry_point(&mut self) {
        self.entry_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_point(&mut self, v: ::std::string::String) {
        self.entry_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry_point(&mut self) -> &mut ::std::string::String {
        &mut self.entry_point
    }

    // Take field
    pub fn take_entry_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entry_point, ::std::string::String::new())
    }

    pub fn get_entry_point(&self) -> &str {
        &self.entry_point
    }

    // repeated .AzureFunctionsRpcMessages.RpcFunctionMetadata.BindingsEntry bindings = 6;

    pub fn clear_bindings(&mut self) {
        self.bindings.clear();
    }

    // Param is passed by value, moved
    pub fn set_bindings(&mut self, v: ::std::collections::HashMap<::std::string::String, BindingInfo>) {
        self.bindings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bindings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, BindingInfo> {
        &mut self.bindings
    }

    // Take field
    pub fn take_bindings(&mut self) -> ::std::collections::HashMap<::std::string::String, BindingInfo> {
        ::std::mem::replace(&mut self.bindings, ::std::collections::HashMap::new())
    }

    pub fn get_bindings(&self) -> &::std::collections::HashMap<::std::string::String, BindingInfo> {
        &self.bindings
    }
}

impl ::protobuf::Message for RpcFunctionMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.directory)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.script_file)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entry_point)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BindingInfo>>(wire_type, is, &mut self.bindings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if !self.script_file.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.script_file);
        }
        if !self.entry_point.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.entry_point);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BindingInfo>>(6, &self.bindings);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if !self.script_file.is_empty() {
            os.write_string(2, &self.script_file)?;
        }
        if !self.entry_point.is_empty() {
            os.write_string(3, &self.entry_point)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BindingInfo>>(6, &self.bindings, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcFunctionMetadata {
        RpcFunctionMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &RpcFunctionMetadata| { &m.name },
                    |m: &mut RpcFunctionMetadata| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "directory",
                    |m: &RpcFunctionMetadata| { &m.directory },
                    |m: &mut RpcFunctionMetadata| { &mut m.directory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "script_file",
                    |m: &RpcFunctionMetadata| { &m.script_file },
                    |m: &mut RpcFunctionMetadata| { &mut m.script_file },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entry_point",
                    |m: &RpcFunctionMetadata| { &m.entry_point },
                    |m: &mut RpcFunctionMetadata| { &mut m.entry_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BindingInfo>>(
                    "bindings",
                    |m: &RpcFunctionMetadata| { &m.bindings },
                    |m: &mut RpcFunctionMetadata| { &mut m.bindings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcFunctionMetadata>(
                    "RpcFunctionMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcFunctionMetadata {
        static mut instance: ::protobuf::lazy::Lazy<RpcFunctionMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcFunctionMetadata,
        };
        unsafe {
            instance.get(RpcFunctionMetadata::new)
        }
    }
}

impl ::protobuf::Clear for RpcFunctionMetadata {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_directory();
        self.clear_script_file();
        self.clear_entry_point();
        self.clear_bindings();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcFunctionMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcFunctionMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvocationRequest {
    // message fields
    pub invocation_id: ::std::string::String,
    pub function_id: ::std::string::String,
    pub input_data: ::protobuf::RepeatedField<ParameterBinding>,
    pub trigger_metadata: ::std::collections::HashMap<::std::string::String, TypedData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl InvocationRequest {
    pub fn new() -> InvocationRequest {
        ::std::default::Default::default()
    }

    // string invocation_id = 1;

    pub fn clear_invocation_id(&mut self) {
        self.invocation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_invocation_id(&mut self, v: ::std::string::String) {
        self.invocation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invocation_id(&mut self) -> &mut ::std::string::String {
        &mut self.invocation_id
    }

    // Take field
    pub fn take_invocation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.invocation_id, ::std::string::String::new())
    }

    pub fn get_invocation_id(&self) -> &str {
        &self.invocation_id
    }

    // string function_id = 2;

    pub fn clear_function_id(&mut self) {
        self.function_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: ::std::string::String) {
        self.function_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_id(&mut self) -> &mut ::std::string::String {
        &mut self.function_id
    }

    // Take field
    pub fn take_function_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function_id, ::std::string::String::new())
    }

    pub fn get_function_id(&self) -> &str {
        &self.function_id
    }

    // repeated .AzureFunctionsRpcMessages.ParameterBinding input_data = 3;

    pub fn clear_input_data(&mut self) {
        self.input_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_data(&mut self, v: ::protobuf::RepeatedField<ParameterBinding>) {
        self.input_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_data(&mut self) -> &mut ::protobuf::RepeatedField<ParameterBinding> {
        &mut self.input_data
    }

    // Take field
    pub fn take_input_data(&mut self) -> ::protobuf::RepeatedField<ParameterBinding> {
        ::std::mem::replace(&mut self.input_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_input_data(&self) -> &[ParameterBinding] {
        &self.input_data
    }

    // repeated .AzureFunctionsRpcMessages.InvocationRequest.TriggerMetadataEntry trigger_metadata = 4;

    pub fn clear_trigger_metadata(&mut self) {
        self.trigger_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, TypedData>) {
        self.trigger_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trigger_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, TypedData> {
        &mut self.trigger_metadata
    }

    // Take field
    pub fn take_trigger_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, TypedData> {
        ::std::mem::replace(&mut self.trigger_metadata, ::std::collections::HashMap::new())
    }

    pub fn get_trigger_metadata(&self) -> &::std::collections::HashMap<::std::string::String, TypedData> {
        &self.trigger_metadata
    }
}

impl ::protobuf::Message for InvocationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.input_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.invocation_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.input_data)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TypedData>>(wire_type, is, &mut self.trigger_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.invocation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.invocation_id);
        }
        if !self.function_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.function_id);
        }
        for value in &self.input_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TypedData>>(4, &self.trigger_metadata);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.invocation_id.is_empty() {
            os.write_string(1, &self.invocation_id)?;
        }
        if !self.function_id.is_empty() {
            os.write_string(2, &self.function_id)?;
        }
        for v in &self.input_data {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TypedData>>(4, &self.trigger_metadata, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvocationRequest {
        InvocationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invocation_id",
                    |m: &InvocationRequest| { &m.invocation_id },
                    |m: &mut InvocationRequest| { &mut m.invocation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "function_id",
                    |m: &InvocationRequest| { &m.function_id },
                    |m: &mut InvocationRequest| { &mut m.function_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ParameterBinding>>(
                    "input_data",
                    |m: &InvocationRequest| { &m.input_data },
                    |m: &mut InvocationRequest| { &mut m.input_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TypedData>>(
                    "trigger_metadata",
                    |m: &InvocationRequest| { &m.trigger_metadata },
                    |m: &mut InvocationRequest| { &mut m.trigger_metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InvocationRequest>(
                    "InvocationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvocationRequest {
        static mut instance: ::protobuf::lazy::Lazy<InvocationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InvocationRequest,
        };
        unsafe {
            instance.get(InvocationRequest::new)
        }
    }
}

impl ::protobuf::Clear for InvocationRequest {
    fn clear(&mut self) {
        self.clear_invocation_id();
        self.clear_function_id();
        self.clear_input_data();
        self.clear_trigger_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvocationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvocationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvocationCancel {
    // message fields
    pub invocation_id: ::std::string::String,
    pub grace_period: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl InvocationCancel {
    pub fn new() -> InvocationCancel {
        ::std::default::Default::default()
    }

    // string invocation_id = 2;

    pub fn clear_invocation_id(&mut self) {
        self.invocation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_invocation_id(&mut self, v: ::std::string::String) {
        self.invocation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invocation_id(&mut self) -> &mut ::std::string::String {
        &mut self.invocation_id
    }

    // Take field
    pub fn take_invocation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.invocation_id, ::std::string::String::new())
    }

    pub fn get_invocation_id(&self) -> &str {
        &self.invocation_id
    }

    // .google.protobuf.Duration grace_period = 1;

    pub fn clear_grace_period(&mut self) {
        self.grace_period.clear();
    }

    pub fn has_grace_period(&self) -> bool {
        self.grace_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grace_period(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.grace_period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grace_period(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.grace_period.is_none() {
            self.grace_period.set_default();
        }
        self.grace_period.as_mut().unwrap()
    }

    // Take field
    pub fn take_grace_period(&mut self) -> ::protobuf::well_known_types::Duration {
        self.grace_period.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    pub fn get_grace_period(&self) -> &::protobuf::well_known_types::Duration {
        self.grace_period.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
}

impl ::protobuf::Message for InvocationCancel {
    fn is_initialized(&self) -> bool {
        for v in &self.grace_period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.invocation_id)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grace_period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.invocation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.invocation_id);
        }
        if let Some(ref v) = self.grace_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.invocation_id.is_empty() {
            os.write_string(2, &self.invocation_id)?;
        }
        if let Some(ref v) = self.grace_period.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvocationCancel {
        InvocationCancel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invocation_id",
                    |m: &InvocationCancel| { &m.invocation_id },
                    |m: &mut InvocationCancel| { &mut m.invocation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "grace_period",
                    |m: &InvocationCancel| { &m.grace_period },
                    |m: &mut InvocationCancel| { &mut m.grace_period },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InvocationCancel>(
                    "InvocationCancel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvocationCancel {
        static mut instance: ::protobuf::lazy::Lazy<InvocationCancel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InvocationCancel,
        };
        unsafe {
            instance.get(InvocationCancel::new)
        }
    }
}

impl ::protobuf::Clear for InvocationCancel {
    fn clear(&mut self) {
        self.clear_invocation_id();
        self.clear_grace_period();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvocationCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvocationCancel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvocationResponse {
    // message fields
    pub invocation_id: ::std::string::String,
    pub output_data: ::protobuf::RepeatedField<ParameterBinding>,
    pub return_value: ::protobuf::SingularPtrField<TypedData>,
    pub result: ::protobuf::SingularPtrField<StatusResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl InvocationResponse {
    pub fn new() -> InvocationResponse {
        ::std::default::Default::default()
    }

    // string invocation_id = 1;

    pub fn clear_invocation_id(&mut self) {
        self.invocation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_invocation_id(&mut self, v: ::std::string::String) {
        self.invocation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invocation_id(&mut self) -> &mut ::std::string::String {
        &mut self.invocation_id
    }

    // Take field
    pub fn take_invocation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.invocation_id, ::std::string::String::new())
    }

    pub fn get_invocation_id(&self) -> &str {
        &self.invocation_id
    }

    // repeated .AzureFunctionsRpcMessages.ParameterBinding output_data = 2;

    pub fn clear_output_data(&mut self) {
        self.output_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_data(&mut self, v: ::protobuf::RepeatedField<ParameterBinding>) {
        self.output_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_data(&mut self) -> &mut ::protobuf::RepeatedField<ParameterBinding> {
        &mut self.output_data
    }

    // Take field
    pub fn take_output_data(&mut self) -> ::protobuf::RepeatedField<ParameterBinding> {
        ::std::mem::replace(&mut self.output_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_output_data(&self) -> &[ParameterBinding] {
        &self.output_data
    }

    // .AzureFunctionsRpcMessages.TypedData return_value = 4;

    pub fn clear_return_value(&mut self) {
        self.return_value.clear();
    }

    pub fn has_return_value(&self) -> bool {
        self.return_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_value(&mut self, v: TypedData) {
        self.return_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_value(&mut self) -> &mut TypedData {
        if self.return_value.is_none() {
            self.return_value.set_default();
        }
        self.return_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_value(&mut self) -> TypedData {
        self.return_value.take().unwrap_or_else(|| TypedData::new())
    }

    pub fn get_return_value(&self) -> &TypedData {
        self.return_value.as_ref().unwrap_or_else(|| TypedData::default_instance())
    }

    // .AzureFunctionsRpcMessages.StatusResult result = 3;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: StatusResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut StatusResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> StatusResult {
        self.result.take().unwrap_or_else(|| StatusResult::new())
    }

    pub fn get_result(&self) -> &StatusResult {
        self.result.as_ref().unwrap_or_else(|| StatusResult::default_instance())
    }
}

impl ::protobuf::Message for InvocationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.output_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.invocation_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.output_data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.return_value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.invocation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.invocation_id);
        }
        for value in &self.output_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.return_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.invocation_id.is_empty() {
            os.write_string(1, &self.invocation_id)?;
        }
        for v in &self.output_data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.return_value.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvocationResponse {
        InvocationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invocation_id",
                    |m: &InvocationResponse| { &m.invocation_id },
                    |m: &mut InvocationResponse| { &mut m.invocation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ParameterBinding>>(
                    "output_data",
                    |m: &InvocationResponse| { &m.output_data },
                    |m: &mut InvocationResponse| { &mut m.output_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypedData>>(
                    "return_value",
                    |m: &InvocationResponse| { &m.return_value },
                    |m: &mut InvocationResponse| { &mut m.return_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusResult>>(
                    "result",
                    |m: &InvocationResponse| { &m.result },
                    |m: &mut InvocationResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InvocationResponse>(
                    "InvocationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvocationResponse {
        static mut instance: ::protobuf::lazy::Lazy<InvocationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InvocationResponse,
        };
        unsafe {
            instance.get(InvocationResponse::new)
        }
    }
}

impl ::protobuf::Clear for InvocationResponse {
    fn clear(&mut self) {
        self.clear_invocation_id();
        self.clear_output_data();
        self.clear_return_value();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvocationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvocationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypedData {
    // message oneof groups
    pub data: ::std::option::Option<TypedData_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum TypedData_oneof_data {
    string(::std::string::String),
    json(::std::string::String),
    bytes(::std::vec::Vec<u8>),
    stream(::std::vec::Vec<u8>),
    http(RpcHttp),
    int(i64),
    double(f64),
}

impl TypedData {
    pub fn new() -> TypedData {
        ::std::default::Default::default()
    }

    // string string = 1;

    pub fn clear_string(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(TypedData_oneof_data::string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TypedData_oneof_data::string(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(TypedData_oneof_data::string(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.data.take() {
                ::std::option::Option::Some(TypedData_oneof_data::string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_string(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::string(ref v)) => v,
            _ => "",
        }
    }

    // string json = 2;

    pub fn clear_json(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_json(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::json(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_json(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(TypedData_oneof_data::json(v))
    }

    // Mutable pointer to the field.
    pub fn mut_json(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(TypedData_oneof_data::json(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(TypedData_oneof_data::json(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::json(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_json(&mut self) -> ::std::string::String {
        if self.has_json() {
            match self.data.take() {
                ::std::option::Option::Some(TypedData_oneof_data::json(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_json(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::json(ref v)) => v,
            _ => "",
        }
    }

    // bytes bytes = 3;

    pub fn clear_bytes(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(TypedData_oneof_data::bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(TypedData_oneof_data::bytes(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(TypedData_oneof_data::bytes(::std::vec::Vec::new()));
        }
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_bytes() {
            match self.data.take() {
                ::std::option::Option::Some(TypedData_oneof_data::bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_bytes(&self) -> &[u8] {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::bytes(ref v)) => v,
            _ => &[],
        }
    }

    // bytes stream = 4;

    pub fn clear_stream(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_stream(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::stream(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(TypedData_oneof_data::stream(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stream(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(TypedData_oneof_data::stream(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(TypedData_oneof_data::stream(::std::vec::Vec::new()));
        }
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::stream(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stream(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_stream() {
            match self.data.take() {
                ::std::option::Option::Some(TypedData_oneof_data::stream(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_stream(&self) -> &[u8] {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::stream(ref v)) => v,
            _ => &[],
        }
    }

    // .AzureFunctionsRpcMessages.RpcHttp http = 5;

    pub fn clear_http(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_http(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::http(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: RpcHttp) {
        self.data = ::std::option::Option::Some(TypedData_oneof_data::http(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http(&mut self) -> &mut RpcHttp {
        if let ::std::option::Option::Some(TypedData_oneof_data::http(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(TypedData_oneof_data::http(RpcHttp::new()));
        }
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::http(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http(&mut self) -> RpcHttp {
        if self.has_http() {
            match self.data.take() {
                ::std::option::Option::Some(TypedData_oneof_data::http(v)) => v,
                _ => panic!(),
            }
        } else {
            RpcHttp::new()
        }
    }

    pub fn get_http(&self) -> &RpcHttp {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::http(ref v)) => v,
            _ => RpcHttp::default_instance(),
        }
    }

    // sint64 int = 6;

    pub fn clear_int(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: i64) {
        self.data = ::std::option::Option::Some(TypedData_oneof_data::int(v))
    }

    pub fn get_int(&self) -> i64 {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::int(v)) => v,
            _ => 0,
        }
    }

    // double double = 7;

    pub fn clear_double(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_double(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: f64) {
        self.data = ::std::option::Option::Some(TypedData_oneof_data::double(v))
    }

    pub fn get_double(&self) -> f64 {
        match self.data {
            ::std::option::Option::Some(TypedData_oneof_data::double(v)) => v,
            _ => 0.,
        }
    }
}

impl ::protobuf::Message for TypedData {
    fn is_initialized(&self) -> bool {
        if let Some(TypedData_oneof_data::http(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TypedData_oneof_data::string(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TypedData_oneof_data::json(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TypedData_oneof_data::bytes(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TypedData_oneof_data::stream(is.read_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TypedData_oneof_data::http(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TypedData_oneof_data::int(is.read_sint64()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TypedData_oneof_data::double(is.read_double()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &TypedData_oneof_data::string(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &TypedData_oneof_data::json(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &TypedData_oneof_data::bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &TypedData_oneof_data::stream(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &TypedData_oneof_data::http(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TypedData_oneof_data::int(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(6, v);
                },
                &TypedData_oneof_data::double(v) => {
                    my_size += 9;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &TypedData_oneof_data::string(ref v) => {
                    os.write_string(1, v)?;
                },
                &TypedData_oneof_data::json(ref v) => {
                    os.write_string(2, v)?;
                },
                &TypedData_oneof_data::bytes(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &TypedData_oneof_data::stream(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &TypedData_oneof_data::http(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TypedData_oneof_data::int(v) => {
                    os.write_sint64(6, v)?;
                },
                &TypedData_oneof_data::double(v) => {
                    os.write_double(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypedData {
        TypedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "string",
                    TypedData::has_string,
                    TypedData::get_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "json",
                    TypedData::has_json,
                    TypedData::get_json,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "bytes",
                    TypedData::has_bytes,
                    TypedData::get_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "stream",
                    TypedData::has_stream,
                    TypedData::get_stream,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RpcHttp>(
                    "http",
                    TypedData::has_http,
                    TypedData::get_http,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "int",
                    TypedData::has_int,
                    TypedData::get_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                    "double",
                    TypedData::has_double,
                    TypedData::get_double,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypedData>(
                    "TypedData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypedData {
        static mut instance: ::protobuf::lazy::Lazy<TypedData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypedData,
        };
        unsafe {
            instance.get(TypedData::new)
        }
    }
}

impl ::protobuf::Clear for TypedData {
    fn clear(&mut self) {
        self.clear_string();
        self.clear_json();
        self.clear_bytes();
        self.clear_stream();
        self.clear_http();
        self.clear_int();
        self.clear_double();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypedData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParameterBinding {
    // message fields
    pub name: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<TypedData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ParameterBinding {
    pub fn new() -> ParameterBinding {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .AzureFunctionsRpcMessages.TypedData data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: TypedData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut TypedData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> TypedData {
        self.data.take().unwrap_or_else(|| TypedData::new())
    }

    pub fn get_data(&self) -> &TypedData {
        self.data.as_ref().unwrap_or_else(|| TypedData::default_instance())
    }
}

impl ::protobuf::Message for ParameterBinding {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParameterBinding {
        ParameterBinding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ParameterBinding| { &m.name },
                    |m: &mut ParameterBinding| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypedData>>(
                    "data",
                    |m: &ParameterBinding| { &m.data },
                    |m: &mut ParameterBinding| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParameterBinding>(
                    "ParameterBinding",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParameterBinding {
        static mut instance: ::protobuf::lazy::Lazy<ParameterBinding> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParameterBinding,
        };
        unsafe {
            instance.get(ParameterBinding::new)
        }
    }
}

impl ::protobuf::Clear for ParameterBinding {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParameterBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParameterBinding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BindingInfo {
    // message fields
    pub field_type: ::std::string::String,
    pub direction: BindingInfo_Direction,
    pub data_type: BindingInfo_DataType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BindingInfo {
    pub fn new() -> BindingInfo {
        ::std::default::Default::default()
    }

    // string type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }

    // .AzureFunctionsRpcMessages.BindingInfo.Direction direction = 3;

    pub fn clear_direction(&mut self) {
        self.direction = BindingInfo_Direction::value_in;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: BindingInfo_Direction) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> BindingInfo_Direction {
        self.direction
    }

    // .AzureFunctionsRpcMessages.BindingInfo.DataType data_type = 4;

    pub fn clear_data_type(&mut self) {
        self.data_type = BindingInfo_DataType::undefined;
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: BindingInfo_DataType) {
        self.data_type = v;
    }

    pub fn get_data_type(&self) -> BindingInfo_DataType {
        self.data_type
    }
}

impl ::protobuf::Message for BindingInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if self.direction != BindingInfo_Direction::value_in {
            my_size += ::protobuf::rt::enum_size(3, self.direction);
        }
        if self.data_type != BindingInfo_DataType::undefined {
            my_size += ::protobuf::rt::enum_size(4, self.data_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if self.direction != BindingInfo_Direction::value_in {
            os.write_enum(3, self.direction.value())?;
        }
        if self.data_type != BindingInfo_DataType::undefined {
            os.write_enum(4, self.data_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BindingInfo {
        BindingInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &BindingInfo| { &m.field_type },
                    |m: &mut BindingInfo| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BindingInfo_Direction>>(
                    "direction",
                    |m: &BindingInfo| { &m.direction },
                    |m: &mut BindingInfo| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BindingInfo_DataType>>(
                    "data_type",
                    |m: &BindingInfo| { &m.data_type },
                    |m: &mut BindingInfo| { &mut m.data_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BindingInfo>(
                    "BindingInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BindingInfo {
        static mut instance: ::protobuf::lazy::Lazy<BindingInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BindingInfo,
        };
        unsafe {
            instance.get(BindingInfo::new)
        }
    }
}

impl ::protobuf::Clear for BindingInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_direction();
        self.clear_data_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BindingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BindingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BindingInfo_Direction {
    value_in = 0,
    out = 1,
    inout = 2,
}

impl ::protobuf::ProtobufEnum for BindingInfo_Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BindingInfo_Direction> {
        match value {
            0 => ::std::option::Option::Some(BindingInfo_Direction::value_in),
            1 => ::std::option::Option::Some(BindingInfo_Direction::out),
            2 => ::std::option::Option::Some(BindingInfo_Direction::inout),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BindingInfo_Direction] = &[
            BindingInfo_Direction::value_in,
            BindingInfo_Direction::out,
            BindingInfo_Direction::inout,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BindingInfo_Direction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BindingInfo_Direction {
}

impl ::std::default::Default for BindingInfo_Direction {
    fn default() -> Self {
        BindingInfo_Direction::value_in
    }
}

impl ::protobuf::reflect::ProtobufValue for BindingInfo_Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BindingInfo_DataType {
    undefined = 0,
    string = 1,
    binary = 2,
    stream = 3,
}

impl ::protobuf::ProtobufEnum for BindingInfo_DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BindingInfo_DataType> {
        match value {
            0 => ::std::option::Option::Some(BindingInfo_DataType::undefined),
            1 => ::std::option::Option::Some(BindingInfo_DataType::string),
            2 => ::std::option::Option::Some(BindingInfo_DataType::binary),
            3 => ::std::option::Option::Some(BindingInfo_DataType::stream),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BindingInfo_DataType] = &[
            BindingInfo_DataType::undefined,
            BindingInfo_DataType::string,
            BindingInfo_DataType::binary,
            BindingInfo_DataType::stream,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BindingInfo_DataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BindingInfo_DataType {
}

impl ::std::default::Default for BindingInfo_DataType {
    fn default() -> Self {
        BindingInfo_DataType::undefined
    }
}

impl ::protobuf::reflect::ProtobufValue for BindingInfo_DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcLog {
    // message fields
    pub invocation_id: ::std::string::String,
    pub category: ::std::string::String,
    pub level: RpcLog_Level,
    pub message: ::std::string::String,
    pub event_id: ::std::string::String,
    pub exception: ::protobuf::SingularPtrField<RpcException>,
    pub properties: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RpcLog {
    pub fn new() -> RpcLog {
        ::std::default::Default::default()
    }

    // string invocation_id = 1;

    pub fn clear_invocation_id(&mut self) {
        self.invocation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_invocation_id(&mut self, v: ::std::string::String) {
        self.invocation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invocation_id(&mut self) -> &mut ::std::string::String {
        &mut self.invocation_id
    }

    // Take field
    pub fn take_invocation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.invocation_id, ::std::string::String::new())
    }

    pub fn get_invocation_id(&self) -> &str {
        &self.invocation_id
    }

    // string category = 2;

    pub fn clear_category(&mut self) {
        self.category.clear();
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category(&mut self) -> &mut ::std::string::String {
        &mut self.category
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.category, ::std::string::String::new())
    }

    pub fn get_category(&self) -> &str {
        &self.category
    }

    // .AzureFunctionsRpcMessages.RpcLog.Level level = 3;

    pub fn clear_level(&mut self) {
        self.level = RpcLog_Level::Trace;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: RpcLog_Level) {
        self.level = v;
    }

    pub fn get_level(&self) -> RpcLog_Level {
        self.level
    }

    // string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }

    // string event_id = 5;

    pub fn clear_event_id(&mut self) {
        self.event_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: ::std::string::String) {
        self.event_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_id(&mut self) -> &mut ::std::string::String {
        &mut self.event_id
    }

    // Take field
    pub fn take_event_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_id, ::std::string::String::new())
    }

    pub fn get_event_id(&self) -> &str {
        &self.event_id
    }

    // .AzureFunctionsRpcMessages.RpcException exception = 6;

    pub fn clear_exception(&mut self) {
        self.exception.clear();
    }

    pub fn has_exception(&self) -> bool {
        self.exception.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: RpcException) {
        self.exception = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception(&mut self) -> &mut RpcException {
        if self.exception.is_none() {
            self.exception.set_default();
        }
        self.exception.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception(&mut self) -> RpcException {
        self.exception.take().unwrap_or_else(|| RpcException::new())
    }

    pub fn get_exception(&self) -> &RpcException {
        self.exception.as_ref().unwrap_or_else(|| RpcException::default_instance())
    }

    // string properties = 7;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::std::string::String) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut ::std::string::String {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.properties, ::std::string::String::new())
    }

    pub fn get_properties(&self) -> &str {
        &self.properties
    }
}

impl ::protobuf::Message for RpcLog {
    fn is_initialized(&self) -> bool {
        for v in &self.exception {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.invocation_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.category)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exception)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.invocation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.invocation_id);
        }
        if !self.category.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.category);
        }
        if self.level != RpcLog_Level::Trace {
            my_size += ::protobuf::rt::enum_size(3, self.level);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.message);
        }
        if !self.event_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.event_id);
        }
        if let Some(ref v) = self.exception.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.properties.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.properties);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.invocation_id.is_empty() {
            os.write_string(1, &self.invocation_id)?;
        }
        if !self.category.is_empty() {
            os.write_string(2, &self.category)?;
        }
        if self.level != RpcLog_Level::Trace {
            os.write_enum(3, self.level.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(4, &self.message)?;
        }
        if !self.event_id.is_empty() {
            os.write_string(5, &self.event_id)?;
        }
        if let Some(ref v) = self.exception.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.properties.is_empty() {
            os.write_string(7, &self.properties)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcLog {
        RpcLog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invocation_id",
                    |m: &RpcLog| { &m.invocation_id },
                    |m: &mut RpcLog| { &mut m.invocation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "category",
                    |m: &RpcLog| { &m.category },
                    |m: &mut RpcLog| { &mut m.category },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RpcLog_Level>>(
                    "level",
                    |m: &RpcLog| { &m.level },
                    |m: &mut RpcLog| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &RpcLog| { &m.message },
                    |m: &mut RpcLog| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_id",
                    |m: &RpcLog| { &m.event_id },
                    |m: &mut RpcLog| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RpcException>>(
                    "exception",
                    |m: &RpcLog| { &m.exception },
                    |m: &mut RpcLog| { &mut m.exception },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "properties",
                    |m: &RpcLog| { &m.properties },
                    |m: &mut RpcLog| { &mut m.properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcLog>(
                    "RpcLog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcLog {
        static mut instance: ::protobuf::lazy::Lazy<RpcLog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcLog,
        };
        unsafe {
            instance.get(RpcLog::new)
        }
    }
}

impl ::protobuf::Clear for RpcLog {
    fn clear(&mut self) {
        self.clear_invocation_id();
        self.clear_category();
        self.clear_level();
        self.clear_message();
        self.clear_event_id();
        self.clear_exception();
        self.clear_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcLog {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RpcLog_Level {
    Trace = 0,
    Debug = 1,
    Information = 2,
    Warning = 3,
    Error = 4,
    Critical = 5,
    None = 6,
}

impl ::protobuf::ProtobufEnum for RpcLog_Level {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RpcLog_Level> {
        match value {
            0 => ::std::option::Option::Some(RpcLog_Level::Trace),
            1 => ::std::option::Option::Some(RpcLog_Level::Debug),
            2 => ::std::option::Option::Some(RpcLog_Level::Information),
            3 => ::std::option::Option::Some(RpcLog_Level::Warning),
            4 => ::std::option::Option::Some(RpcLog_Level::Error),
            5 => ::std::option::Option::Some(RpcLog_Level::Critical),
            6 => ::std::option::Option::Some(RpcLog_Level::None),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RpcLog_Level] = &[
            RpcLog_Level::Trace,
            RpcLog_Level::Debug,
            RpcLog_Level::Information,
            RpcLog_Level::Warning,
            RpcLog_Level::Error,
            RpcLog_Level::Critical,
            RpcLog_Level::None,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RpcLog_Level", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RpcLog_Level {
}

impl ::std::default::Default for RpcLog_Level {
    fn default() -> Self {
        RpcLog_Level::Trace
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcLog_Level {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcException {
    // message fields
    pub source: ::std::string::String,
    pub stack_trace: ::std::string::String,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RpcException {
    pub fn new() -> RpcException {
        ::std::default::Default::default()
    }

    // string source = 3;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    pub fn get_source(&self) -> &str {
        &self.source
    }

    // string stack_trace = 1;

    pub fn clear_stack_trace(&mut self) {
        self.stack_trace.clear();
    }

    // Param is passed by value, moved
    pub fn set_stack_trace(&mut self, v: ::std::string::String) {
        self.stack_trace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stack_trace(&mut self) -> &mut ::std::string::String {
        &mut self.stack_trace
    }

    // Take field
    pub fn take_stack_trace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stack_trace, ::std::string::String::new())
    }

    pub fn get_stack_trace(&self) -> &str {
        &self.stack_trace
    }

    // string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for RpcException {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stack_trace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        if !self.stack_trace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.stack_trace);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        if !self.stack_trace.is_empty() {
            os.write_string(1, &self.stack_trace)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcException {
        RpcException::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &RpcException| { &m.source },
                    |m: &mut RpcException| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stack_trace",
                    |m: &RpcException| { &m.stack_trace },
                    |m: &mut RpcException| { &mut m.stack_trace },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &RpcException| { &m.message },
                    |m: &mut RpcException| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcException>(
                    "RpcException",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcException {
        static mut instance: ::protobuf::lazy::Lazy<RpcException> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcException,
        };
        unsafe {
            instance.get(RpcException::new)
        }
    }
}

impl ::protobuf::Clear for RpcException {
    fn clear(&mut self) {
        self.clear_source();
        self.clear_stack_trace();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcException {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcHttp {
    // message fields
    pub method: ::std::string::String,
    pub url: ::std::string::String,
    pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub body: ::protobuf::SingularPtrField<TypedData>,
    pub params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub status_code: ::std::string::String,
    pub query: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub enable_content_negotiation: bool,
    pub rawBody: ::protobuf::SingularPtrField<TypedData>,
    pub identities: ::protobuf::RepeatedField<super::ClaimsIdentityRpc::RpcClaimsIdentity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RpcHttp {
    pub fn new() -> RpcHttp {
        ::std::default::Default::default()
    }

    // string method = 1;

    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: ::std::string::String) {
        self.method = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method(&mut self) -> &mut ::std::string::String {
        &mut self.method
    }

    // Take field
    pub fn take_method(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.method, ::std::string::String::new())
    }

    pub fn get_method(&self) -> &str {
        &self.method
    }

    // string url = 2;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    pub fn get_url(&self) -> &str {
        &self.url
    }

    // repeated .AzureFunctionsRpcMessages.RpcHttp.HeadersEntry headers = 3;

    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.headers, ::std::collections::HashMap::new())
    }

    pub fn get_headers(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.headers
    }

    // .AzureFunctionsRpcMessages.TypedData body = 4;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: TypedData) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut TypedData {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> TypedData {
        self.body.take().unwrap_or_else(|| TypedData::new())
    }

    pub fn get_body(&self) -> &TypedData {
        self.body.as_ref().unwrap_or_else(|| TypedData::default_instance())
    }

    // repeated .AzureFunctionsRpcMessages.RpcHttp.ParamsEntry params = 10;

    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.params, ::std::collections::HashMap::new())
    }

    pub fn get_params(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.params
    }

    // string status_code = 12;

    pub fn clear_status_code(&mut self) {
        self.status_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: ::std::string::String) {
        self.status_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_code(&mut self) -> &mut ::std::string::String {
        &mut self.status_code
    }

    // Take field
    pub fn take_status_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_code, ::std::string::String::new())
    }

    pub fn get_status_code(&self) -> &str {
        &self.status_code
    }

    // repeated .AzureFunctionsRpcMessages.RpcHttp.QueryEntry query = 15;

    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.query = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.query, ::std::collections::HashMap::new())
    }

    pub fn get_query(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.query
    }

    // bool enable_content_negotiation = 16;

    pub fn clear_enable_content_negotiation(&mut self) {
        self.enable_content_negotiation = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_content_negotiation(&mut self, v: bool) {
        self.enable_content_negotiation = v;
    }

    pub fn get_enable_content_negotiation(&self) -> bool {
        self.enable_content_negotiation
    }

    // .AzureFunctionsRpcMessages.TypedData rawBody = 17;

    pub fn clear_rawBody(&mut self) {
        self.rawBody.clear();
    }

    pub fn has_rawBody(&self) -> bool {
        self.rawBody.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawBody(&mut self, v: TypedData) {
        self.rawBody = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawBody(&mut self) -> &mut TypedData {
        if self.rawBody.is_none() {
            self.rawBody.set_default();
        }
        self.rawBody.as_mut().unwrap()
    }

    // Take field
    pub fn take_rawBody(&mut self) -> TypedData {
        self.rawBody.take().unwrap_or_else(|| TypedData::new())
    }

    pub fn get_rawBody(&self) -> &TypedData {
        self.rawBody.as_ref().unwrap_or_else(|| TypedData::default_instance())
    }

    // repeated .RpcClaimsIdentity identities = 18;

    pub fn clear_identities(&mut self) {
        self.identities.clear();
    }

    // Param is passed by value, moved
    pub fn set_identities(&mut self, v: ::protobuf::RepeatedField<super::ClaimsIdentityRpc::RpcClaimsIdentity>) {
        self.identities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_identities(&mut self) -> &mut ::protobuf::RepeatedField<super::ClaimsIdentityRpc::RpcClaimsIdentity> {
        &mut self.identities
    }

    // Take field
    pub fn take_identities(&mut self) -> ::protobuf::RepeatedField<super::ClaimsIdentityRpc::RpcClaimsIdentity> {
        ::std::mem::replace(&mut self.identities, ::protobuf::RepeatedField::new())
    }

    pub fn get_identities(&self) -> &[super::ClaimsIdentityRpc::RpcClaimsIdentity] {
        &self.identities
    }
}

impl ::protobuf::Message for RpcHttp {
    fn is_initialized(&self) -> bool {
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rawBody {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.identities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.headers)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.params)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_code)?;
                },
                15 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.query)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_content_negotiation = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rawBody)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.identities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.method);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.headers);
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.params);
        if !self.status_code.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.status_code);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(15, &self.query);
        if self.enable_content_negotiation != false {
            my_size += 3;
        }
        if let Some(ref v) = self.rawBody.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.identities {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.method.is_empty() {
            os.write_string(1, &self.method)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.headers, os)?;
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.params, os)?;
        if !self.status_code.is_empty() {
            os.write_string(12, &self.status_code)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(15, &self.query, os)?;
        if self.enable_content_negotiation != false {
            os.write_bool(16, self.enable_content_negotiation)?;
        }
        if let Some(ref v) = self.rawBody.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.identities {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcHttp {
        RpcHttp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "method",
                    |m: &RpcHttp| { &m.method },
                    |m: &mut RpcHttp| { &mut m.method },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &RpcHttp| { &m.url },
                    |m: &mut RpcHttp| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "headers",
                    |m: &RpcHttp| { &m.headers },
                    |m: &mut RpcHttp| { &mut m.headers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypedData>>(
                    "body",
                    |m: &RpcHttp| { &m.body },
                    |m: &mut RpcHttp| { &mut m.body },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "params",
                    |m: &RpcHttp| { &m.params },
                    |m: &mut RpcHttp| { &mut m.params },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status_code",
                    |m: &RpcHttp| { &m.status_code },
                    |m: &mut RpcHttp| { &mut m.status_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &RpcHttp| { &m.query },
                    |m: &mut RpcHttp| { &mut m.query },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_content_negotiation",
                    |m: &RpcHttp| { &m.enable_content_negotiation },
                    |m: &mut RpcHttp| { &mut m.enable_content_negotiation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypedData>>(
                    "rawBody",
                    |m: &RpcHttp| { &m.rawBody },
                    |m: &mut RpcHttp| { &mut m.rawBody },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::ClaimsIdentityRpc::RpcClaimsIdentity>>(
                    "identities",
                    |m: &RpcHttp| { &m.identities },
                    |m: &mut RpcHttp| { &mut m.identities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcHttp>(
                    "RpcHttp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcHttp {
        static mut instance: ::protobuf::lazy::Lazy<RpcHttp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcHttp,
        };
        unsafe {
            instance.get(RpcHttp::new)
        }
    }
}

impl ::protobuf::Clear for RpcHttp {
    fn clear(&mut self) {
        self.clear_method();
        self.clear_url();
        self.clear_headers();
        self.clear_body();
        self.clear_params();
        self.clear_status_code();
        self.clear_query();
        self.clear_enable_content_negotiation();
        self.clear_rawBody();
        self.clear_identities();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcHttp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcHttp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11FunctionRpc.proto\x12\x19AzureFunctionsRpcMessages\x1a\x1egoogle/p\
    rotobuf/duration.proto\x1a\x20identity/ClaimsIdentityRpc.proto\"\xf1\r\n\
    \x10StreamingMessage\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\tR\trequestI\
    d\x12K\n\x0cstart_stream\x18\x14\x20\x01(\x0b2&.AzureFunctionsRpcMessage\
    s.StartStreamH\0R\x0bstartStream\x12^\n\x13worker_init_request\x18\x11\
    \x20\x01(\x0b2,.AzureFunctionsRpcMessages.WorkerInitRequestH\0R\x11worke\
    rInitRequest\x12a\n\x14worker_init_response\x18\x10\x20\x01(\x0b2-.Azure\
    FunctionsRpcMessages.WorkerInitResponseH\0R\x12workerInitResponse\x12W\n\
    \x10worker_heartbeat\x18\x0f\x20\x01(\x0b2*.AzureFunctionsRpcMessages.Wo\
    rkerHeartbeatH\0R\x0fworkerHeartbeat\x12W\n\x10worker_terminate\x18\x0e\
    \x20\x01(\x0b2*.AzureFunctionsRpcMessages.WorkerTerminateH\0R\x0fworkerT\
    erminate\x12d\n\x15worker_status_request\x18\x0c\x20\x01(\x0b2..AzureFun\
    ctionsRpcMessages.WorkerStatusRequestH\0R\x13workerStatusRequest\x12g\n\
    \x16worker_status_response\x18\r\x20\x01(\x0b2/.AzureFunctionsRpcMessage\
    s.WorkerStatusResponseH\0R\x14workerStatusResponse\x12n\n\x19file_change\
    _event_request\x18\x06\x20\x01(\x0b21.AzureFunctionsRpcMessages.FileChan\
    geEventRequestH\0R\x16fileChangeEventRequest\x12g\n\x16worker_action_res\
    ponse\x18\x07\x20\x01(\x0b2/.AzureFunctionsRpcMessages.WorkerActionRespo\
    nseH\0R\x14workerActionResponse\x12d\n\x15function_load_request\x18\x08\
    \x20\x01(\x0b2..AzureFunctionsRpcMessages.FunctionLoadRequestH\0R\x13fun\
    ctionLoadRequest\x12g\n\x16function_load_response\x18\t\x20\x01(\x0b2/.A\
    zureFunctionsRpcMessages.FunctionLoadResponseH\0R\x14functionLoadRespons\
    e\x12]\n\x12invocation_request\x18\x04\x20\x01(\x0b2,.AzureFunctionsRpcM\
    essages.InvocationRequestH\0R\x11invocationRequest\x12`\n\x13invocation_\
    response\x18\x05\x20\x01(\x0b2-.AzureFunctionsRpcMessages.InvocationResp\
    onseH\0R\x12invocationResponse\x12Z\n\x11invocation_cancel\x18\x15\x20\
    \x01(\x0b2+.AzureFunctionsRpcMessages.InvocationCancelH\0R\x10invocation\
    Cancel\x12<\n\x07rpc_log\x18\x02\x20\x01(\x0b2!.AzureFunctionsRpcMessage\
    s.RpcLogH\0R\x06rpcLog\x12\x8c\x01\n#function_environment_reload_request\
    \x18\x19\x20\x01(\x0b2;.AzureFunctionsRpcMessages.FunctionEnvironmentRel\
    oadRequestH\0R\x20functionEnvironmentReloadRequest\x12\x8f\x01\n$functio\
    n_environment_reload_response\x18\x1a\x20\x01(\x0b2<.AzureFunctionsRpcMe\
    ssages.FunctionEnvironmentReloadResponseH\0R!functionEnvironmentReloadRe\
    sponseB\t\n\x07content\"*\n\x0bStartStream\x12\x1b\n\tworker_id\x18\x02\
    \x20\x01(\tR\x08workerId\"\xae\x03\n\x11WorkerInitRequest\x12!\n\x0chost\
    _version\x18\x01\x20\x01(\tR\x0bhostVersion\x12b\n\x0ccapabilities\x18\
    \x02\x20\x03(\x0b2>.AzureFunctionsRpcMessages.WorkerInitRequest.Capabili\
    tiesEntryR\x0ccapabilities\x12f\n\x0elog_categories\x18\x03\x20\x03(\x0b\
    2?.AzureFunctionsRpcMessages.WorkerInitRequest.LogCategoriesEntryR\rlogC\
    ategories\x1a?\n\x11CapabilitiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    i\n\x12LogCategoriesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12=\n\x05value\x18\x02\x20\x01(\x0e2'.AzureFunctionsRpcMessages.RpcLog\
    .LevelR\x05value:\x028\x01\"\xa2\x02\n\x12WorkerInitResponse\x12%\n\x0ew\
    orker_version\x18\x01\x20\x01(\tR\rworkerVersion\x12c\n\x0ccapabilities\
    \x18\x02\x20\x03(\x0b2?.AzureFunctionsRpcMessages.WorkerInitResponse.Cap\
    abilitiesEntryR\x0ccapabilities\x12?\n\x06result\x18\x03\x20\x01(\x0b2'.\
    AzureFunctionsRpcMessages.StatusResultR\x06result\x1a?\n\x11Capabilities\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\x9f\x02\n\x0cStatusResult\x12F\n\
    \x06status\x18\x04\x20\x01(\x0e2..AzureFunctionsRpcMessages.StatusResult\
    .StatusR\x06status\x12\x16\n\x06result\x18\x01\x20\x01(\tR\x06result\x12\
    E\n\texception\x18\x02\x20\x01(\x0b2'.AzureFunctionsRpcMessages.RpcExcep\
    tionR\texception\x125\n\x04logs\x18\x03\x20\x03(\x0b2!.AzureFunctionsRpc\
    Messages.RpcLogR\x04logs\"1\n\x06Status\x12\x0b\n\x07Failure\x10\0\x12\
    \x0b\n\x07Success\x10\x01\x12\r\n\tCancelled\x10\x02\"\x11\n\x0fWorkerHe\
    artbeat\"O\n\x0fWorkerTerminate\x12<\n\x0cgrace_period\x18\x01\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x0bgracePeriod\"\xe7\x01\n\x16FileCh\
    angeEventRequest\x12J\n\x04type\x18\x01\x20\x01(\x0e26.AzureFunctionsRpc\
    Messages.FileChangeEventRequest.TypeR\x04type\x12\x1b\n\tfull_path\x18\
    \x02\x20\x01(\tR\x08fullPath\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04na\
    me\"P\n\x04Type\x12\x0b\n\x07Unknown\x10\0\x12\x0b\n\x07Created\x10\x01\
    \x12\x0b\n\x07Deleted\x10\x02\x12\x0b\n\x07Changed\x10\x04\x12\x0b\n\x07\
    Renamed\x10\x08\x12\x07\n\x03All\x10\x0f\"\xa1\x01\n\x14WorkerActionResp\
    onse\x12N\n\x06action\x18\x01\x20\x01(\x0e26.AzureFunctionsRpcMessages.W\
    orkerActionResponse.ActionR\x06action\x12\x16\n\x06reason\x18\x02\x20\
    \x01(\tR\x06reason\"!\n\x06Action\x12\x0b\n\x07Restart\x10\0\x12\n\n\x06\
    Reload\x10\x01\"\x15\n\x13WorkerStatusRequest\"\x16\n\x14WorkerStatusRes\
    ponse\"\xf8\x01\n\x20FunctionEnvironmentReloadRequest\x12\x8a\x01\n\x15e\
    nvironment_variables\x18\x01\x20\x03(\x0b2U.AzureFunctionsRpcMessages.Fu\
    nctionEnvironmentReloadRequest.EnvironmentVariablesEntryR\x14environment\
    Variables\x1aG\n\x19EnvironmentVariablesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"d\n!FunctionEnvironmentReloadResponse\x12?\n\x06result\x18\x03\
    \x20\x01(\x0b2'.AzureFunctionsRpcMessages.StatusResultR\x06result\"\xc0\
    \x01\n\x13FunctionLoadRequest\x12\x1f\n\x0bfunction_id\x18\x01\x20\x01(\
    \tR\nfunctionId\x12J\n\x08metadata\x18\x02\x20\x01(\x0b2..AzureFunctions\
    RpcMessages.RpcFunctionMetadataR\x08metadata\x12<\n\x1amanaged_dependenc\
    y_enabled\x18\x03\x20\x01(\x08R\x18managedDependencyEnabled\"\xb2\x01\n\
    \x14FunctionLoadResponse\x12\x1f\n\x0bfunction_id\x18\x01\x20\x01(\tR\nf\
    unctionId\x12?\n\x06result\x18\x02\x20\x01(\x0b2'.AzureFunctionsRpcMessa\
    ges.StatusResultR\x06result\x128\n\x18is_dependency_downloaded\x18\x03\
    \x20\x01(\x08R\x16isDependencyDownloaded\"\xc8\x02\n\x13RpcFunctionMetad\
    ata\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12\x1c\n\tdirectory\
    \x18\x01\x20\x01(\tR\tdirectory\x12\x1f\n\x0bscript_file\x18\x02\x20\x01\
    (\tR\nscriptFile\x12\x1f\n\x0bentry_point\x18\x03\x20\x01(\tR\nentryPoin\
    t\x12X\n\x08bindings\x18\x06\x20\x03(\x0b2<.AzureFunctionsRpcMessages.Rp\
    cFunctionMetadata.BindingsEntryR\x08bindings\x1ac\n\rBindingsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12<\n\x05value\x18\x02\x20\x01\
    (\x0b2&.AzureFunctionsRpcMessages.BindingInfoR\x05value:\x028\x01\"\xfd\
    \x02\n\x11InvocationRequest\x12#\n\rinvocation_id\x18\x01\x20\x01(\tR\
    \x0cinvocationId\x12\x1f\n\x0bfunction_id\x18\x02\x20\x01(\tR\nfunctionI\
    d\x12J\n\ninput_data\x18\x03\x20\x03(\x0b2+.AzureFunctionsRpcMessages.Pa\
    rameterBindingR\tinputData\x12l\n\x10trigger_metadata\x18\x04\x20\x03(\
    \x0b2A.AzureFunctionsRpcMessages.InvocationRequest.TriggerMetadataEntryR\
    \x0ftriggerMetadata\x1ah\n\x14TriggerMetadataEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12:\n\x05value\x18\x02\x20\x01(\x0b2$.AzureFunc\
    tionsRpcMessages.TypedDataR\x05value:\x028\x01\"u\n\x10InvocationCancel\
    \x12#\n\rinvocation_id\x18\x02\x20\x01(\tR\x0cinvocationId\x12<\n\x0cgra\
    ce_period\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0bgracePe\
    riod\"\x91\x02\n\x12InvocationResponse\x12#\n\rinvocation_id\x18\x01\x20\
    \x01(\tR\x0cinvocationId\x12L\n\x0boutput_data\x18\x02\x20\x03(\x0b2+.Az\
    ureFunctionsRpcMessages.ParameterBindingR\noutputData\x12G\n\x0creturn_v\
    alue\x18\x04\x20\x01(\x0b2$.AzureFunctionsRpcMessages.TypedDataR\x0bretu\
    rnValue\x12?\n\x06result\x18\x03\x20\x01(\x0b2'.AzureFunctionsRpcMessage\
    s.StatusResultR\x06result\"\xdd\x01\n\tTypedData\x12\x18\n\x06string\x18\
    \x01\x20\x01(\tH\0R\x06string\x12\x14\n\x04json\x18\x02\x20\x01(\tH\0R\
    \x04json\x12\x16\n\x05bytes\x18\x03\x20\x01(\x0cH\0R\x05bytes\x12\x18\n\
    \x06stream\x18\x04\x20\x01(\x0cH\0R\x06stream\x128\n\x04http\x18\x05\x20\
    \x01(\x0b2\".AzureFunctionsRpcMessages.RpcHttpH\0R\x04http\x12\x12\n\x03\
    int\x18\x06\x20\x01(\x12H\0R\x03int\x12\x18\n\x06double\x18\x07\x20\x01(\
    \x01H\0R\x06doubleB\x06\n\x04data\"`\n\x10ParameterBinding\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x128\n\x04data\x18\x02\x20\x01(\x0b2$.A\
    zureFunctionsRpcMessages.TypedDataR\x04data\"\xa7\x02\n\x0bBindingInfo\
    \x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12N\n\tdirection\x18\x03\
    \x20\x01(\x0e20.AzureFunctionsRpcMessages.BindingInfo.DirectionR\tdirect\
    ion\x12L\n\tdata_type\x18\x04\x20\x01(\x0e2/.AzureFunctionsRpcMessages.B\
    indingInfo.DataTypeR\x08dataType\"'\n\tDirection\x12\x06\n\x02in\x10\0\
    \x12\x07\n\x03out\x10\x01\x12\t\n\x05inout\x10\x02\"=\n\x08DataType\x12\
    \r\n\tundefined\x10\0\x12\n\n\x06string\x10\x01\x12\n\n\x06binary\x10\
    \x02\x12\n\n\x06stream\x10\x03\"\x84\x03\n\x06RpcLog\x12#\n\rinvocation_\
    id\x18\x01\x20\x01(\tR\x0cinvocationId\x12\x1a\n\x08category\x18\x02\x20\
    \x01(\tR\x08category\x12=\n\x05level\x18\x03\x20\x01(\x0e2'.AzureFunctio\
    nsRpcMessages.RpcLog.LevelR\x05level\x12\x18\n\x07message\x18\x04\x20\
    \x01(\tR\x07message\x12\x19\n\x08event_id\x18\x05\x20\x01(\tR\x07eventId\
    \x12E\n\texception\x18\x06\x20\x01(\x0b2'.AzureFunctionsRpcMessages.RpcE\
    xceptionR\texception\x12\x1e\n\nproperties\x18\x07\x20\x01(\tR\nproperti\
    es\"^\n\x05Level\x12\t\n\x05Trace\x10\0\x12\t\n\x05Debug\x10\x01\x12\x0f\
    \n\x0bInformation\x10\x02\x12\x0b\n\x07Warning\x10\x03\x12\t\n\x05Error\
    \x10\x04\x12\x0c\n\x08Critical\x10\x05\x12\x08\n\x04None\x10\x06\"a\n\
    \x0cRpcException\x12\x16\n\x06source\x18\x03\x20\x01(\tR\x06source\x12\
    \x1f\n\x0bstack_trace\x18\x01\x20\x01(\tR\nstackTrace\x12\x18\n\x07messa\
    ge\x18\x02\x20\x01(\tR\x07message\"\xc9\x05\n\x07RpcHttp\x12\x16\n\x06me\
    thod\x18\x01\x20\x01(\tR\x06method\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12I\n\x07headers\x18\x03\x20\x03(\x0b2/.AzureFunctionsRpcMessag\
    es.RpcHttp.HeadersEntryR\x07headers\x128\n\x04body\x18\x04\x20\x01(\x0b2\
    $.AzureFunctionsRpcMessages.TypedDataR\x04body\x12F\n\x06params\x18\n\
    \x20\x03(\x0b2..AzureFunctionsRpcMessages.RpcHttp.ParamsEntryR\x06params\
    \x12\x1f\n\x0bstatus_code\x18\x0c\x20\x01(\tR\nstatusCode\x12C\n\x05quer\
    y\x18\x0f\x20\x03(\x0b2-.AzureFunctionsRpcMessages.RpcHttp.QueryEntryR\
    \x05query\x12<\n\x1aenable_content_negotiation\x18\x10\x20\x01(\x08R\x18\
    enableContentNegotiation\x12>\n\x07rawBody\x18\x11\x20\x01(\x0b2$.AzureF\
    unctionsRpcMessages.TypedDataR\x07rawBody\x122\n\nidentities\x18\x12\x20\
    \x03(\x0b2\x12.RpcClaimsIdentityR\nidentities\x1a:\n\x0cHeadersEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a9\n\x0bParamsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a8\n\nQueryEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x012|\n\x0bFuncti\
    onRpc\x12m\n\x0bEventStream\x12+.AzureFunctionsRpcMessages.StreamingMess\
    age\x1a+.AzureFunctionsRpcMessages.StreamingMessage\"\0(\x010\x01B\xa5\
    \x01\n*com.microsoft.azure.functions.rpc.messagesB\rFunctionProtoP\x01Z7\
    github.com/Azure/azure-functions-go-worker/internal/rpc\xaa\x02,Microsof\
    t.Azure.WebJobs.Script.Grpc.Messagesb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
